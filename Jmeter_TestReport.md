# Тестирование производительности с помощью Jmeter

Для начала добавим к нашему `Test Plan` необходимые компоненты, а именно:
`Test plan` -> `Add` -> `Threads (Users)` -> `Thread Group`. 

`Thread Group` - это группа компонентов, отвечающих за характеристики потоков (виртуальных пользователей) в ходе проведения тестирования.
`Thread Group` является компонентом первого уровня (не могут быть вложены в другие компоненты, не считая корневого `Test Plan`)

После того как мы создали первый набор потоков внесем следующие параметры (`Thread Properties`):

- `Number of Threads (users)` = 100 (это количество потоков или виртуальных пользователей),
- `Ramp-up period (seconds)` = 10 (в течение данного промежутка времени (в секундах) будут постепенно запускаться потоки, которые мы прописали в `Number of Threads (users)`) 
- `Loop Count` = 1 (сколько раз потоки выполнят сценарий) 

> > Входные данные выбраны случайным образом для иллюстрации

![](https://github.com/Evergaarden/apache_jmeter/blob/main/img/thread_group_config.png?raw=true)

Теперь создадим шаблон для наших последующих HTTP-сэмплеров, 

`Test plan` -> `Add` -> `Config Element` -> `HTTP Request Defaults`. В созданном шаблоне укажем следующие параметры:
- `Protocol [http]` : `http`
- `Server Name or IP` : `162.55.220.72`
- `Port Number` : `5005`

![](https://github.com/Evergaarden/apache_jmeter/blob/main/img/javaw_9A2tHRU5vD.png?raw=true)

Создадим HTTP-сэмплер 
`Test plan` -> `Add` -> `Sampler` -> `HTTP Request`.

Параметры:

- `HTTP Request` : `POST`
- `Path` : `/login`

Параметры `Web Server` мы заполнили в предыдущем шаблоне, поэтому здесь входные поля можно оставить пустыми

Также заполним `Body Data` для HTTP-сэмплера, воспользуясь json форматом `{key:value}`
          
          {
          "login":"Bogdan",
	       "password":"Qwerty123"
          }
	  
![](https://github.com/Evergaarden/apache_jmeter/blob/main/img/javaw_w0vwcwrBDu.png?raw=true)

Далее добавим `Listener`

В JMeter `Listener` - это группа компонентов, собирающих различную информацию в ходе проведения тестирования. В свою очередь, это позволяют визуализировать данные, касающиеся прохождения теста в реальном времени.

Итак, воспользуемся `View Result Tree` (детальный результат выполнения запросов в виде списка) и `Summary Report` (таблица основных показателей с группировкой по имени сэмплера)

![](https://github.com/Evergaarden/apache_jmeter/blob/main/img/javaw_3obTyeEpGO.png?raw=true)


Теперь можно запустить потоки и посмотреть результаты прогона теста. Для этого нажимаем значок `Start` И далее смотрим в `View Result Tree` и `Summary Report`

Наиболее важные результаты для `Summary Report`: 

- `Samples` : количество виртуальных позвателей + их сценарий (количество запросов)
- `Average` : среднее время отлика от сервера каждого запроса (в миллисекундах)
- `Min` : минимальное зафиксированное время отлика от сервера (в миллисекундах)
- `Max` : максимальное зафиксированное время отлика от сервера (в миллисекундах)
- `Std. Dev` : стандартное отклонение
- `Error %` : зафиксированный процент ошибок
- `Throughput` : пропускная способность (количество запросов в секунду)

![])https://github.com/Evergaarden/apache_jmeter/blob/main/img/javaw_gcDlasKDPU.png?raw=true)


Результаты для `View Result Tree` менее информативны об общих результатах деградации системы, если таковая имеется, но тем не менее можно увидеть следующие моменты:
- `Sampler result` : содержит информацию по каждому сэмплу (код ответа, количество циклов, тип данных и др) 

![](https://github.com/Evergaarden/apache_jmeter/blob/main/img/hmkFk2ZtgK.png?raw=true)

- `Request` : содержит краткую информацию о хедерах и теле запроса  

![](https://github.com/Evergaarden/apache_jmeter/blob/main/img/javaw_ZBnOxtyjbo.png?raw=true)

- `Response data` : содержит краткую информацию о хедерах и теле ответа

![](https://github.com/Evergaarden/apache_jmeter/blob/main/img/javaw_77701679sp.png?raw=true)


> > Хочется отметить, что использование того или иного `Listener` зависит от ситуации. Необохдимо понять, для кого будет визуализирован график и какая цель преследуется. 
> > Нет никакого смысла добавлять множество графиков времени отклика приложения в отчет по каждой операции, если ваша цель — определить, есть ли утечки памяти, зафиксирована ли нестабильная работа во время теста надежности, или если вам нужно сравнить два релиза между собой в рамках регрессионного тестирования. 








